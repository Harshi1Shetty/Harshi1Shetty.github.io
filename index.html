<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>LoLOLOLo</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background-color: #f4f4f4;
    }
    h1 {
      text-align: center;
    }
    .button-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 600px;
      margin: auto;
    }
    button {
      padding: 10px;
      font-size: 16px;
      cursor: pointer;
    }
    .copy-notice {
      color: green;
      text-align: center;
      margin-top: 20px;
    }
  </style>
</head>
<body>

<h1>Om Namah Shivay</h1>
<div class="button-container">
  <button onclick="copyCode('exp04')">Copy EXP04 (BFS)</button>
  <button onclick="copyCode('exp05')">Copy EXP05 (DFS)</button>
  <button onclick="copyCode('exp06')">Copy EXP06 (A* Algorithm)</button>
  <button onclick="copyCode('exp08')">Copy EXP08 (Perceptron)</button>
  <button onclick="copyCode('exp09')">Copy EXP09 (Supervised ML)</button>
</div>
<div class="copy-notice" id="notice"></div>

<script>
  const codes = {
    exp04: `%connected(+Start, +Goal, -Weight)
connected(1,7,1).
connected(1,8,1).
connected(1,3,1).
connected(7,4,1).
connected(7,20,1).
connected(7,17,1).
connected(8,6,1).
connected(3,9,1).
connected(3,12,1).
connected(9,19,1).
connected(4,42,1).
connected(20,28,1).
connected(17,10,1).
connected2(X,Y,D) :- connected(X,Y,D).
connected2(X,Y,D) :- connected(Y,X,D).
next_node(Current, Next, Path) :-
  connected2(Current, Next, _),
  not(member(Next, Path)).
breadth_first(Goal, Goal, _,[Goal]).
breadth_first(Start, Goal, Visited, Path) :-
  findall(X,
    (connected2(X,Start,_),not(member(X,Visited))),
    [T|Extend]),
  write(Visited), nl,
  append(Visited, [T|Extend], Visited2),
  append(Path, [T|Extend], [Next|Path2]),
  breadth_first(Next, Goal, Visited2, Path2).`,

    exp05: `% solve( Node, Solution):
% Solution is an acyclic path (in reverse order) between Node and a goal
solve( Node, Solution)  :- 
  depthfirst( [], Node, Solution).
% depthfirst( Path, Node, Solution): 
% extending the path [Node | Path] to a goal gives Solution
depthfirst( Path, Node, [Node | Path] )  :- 
  goal( Node).
depthfirst( Path, Node, Sol)  :- 
  s( Node, Node1),
  \\+ member( Node1, Path),
  depthfirst( [Node | Path], Node1, Sol).
depthfirst2( Node, [Node], _)  :- 
  goal( Node).
depthfirst2( Node, [Node | Sol], Maxdepth)  :- 
  Maxdepth> 0,
  s( Node, Node1),
  Max1 is Maxdepth - 1,
  depthfirst2( Node1, Sol, Max1).
goal(f).
goal(j).
s(a,b).
s(a,c).
s(b,d).
s(b,e).
s(c,f).
s(c,g).
s(d,h).
s(e,i).
s(e,j).`,

    exp06: `% A* Search Algorithm in Prolog
edge(a, b, 2).
edge(a, c, 3).
edge(b, c, 1).
edge(b, d, 4).
edge(c, d, 2).
heuristic(a, d, 6).
heuristic(b, d, 4).
heuristic(c, d, 2).
heuristic(d, d, 0).
astar(Start, Goal, Path, Cost) :-
  astar(Start, Goal, [Start], Path, Cost, 0).
astar(Start, Goal, Visited, Path, Cost, AccCost) :-
  edge(Start, Next, EdgeCost),
  \\+ member(Next, Visited),
  NewCost is AccCost + EdgeCost,
  NewVisited = [Next|Visited],
  ( Next = Goal
    -> Path = NewVisited,
       Cost = NewCost
    ;  astar(Next, Goal, NewVisited, Path, Cost, NewCost) ).`,

    exp08: `import numpy as np
def unitStep(v):
  if v >= 0:
    return 1
  else:
    return 0
def perceptronModel(x, w, b):
  v = np.dot(w, x) + b
  y = unitStep(v)
  return y
def OR_logicFunction(x):
  w = np.array([1, 1])
  b = -0.5
  return perceptronModel(x, w, b)
test1 = np.array([0, 0])
test2 = np.array([0, 1])
test3 = np.array([1, 0])
test4 = np.array([1, 1])
print("OR({}, {}) = {}".format(0, 0, OR_logicFunction(test1)))
print("OR({}, {}) = {}".format(0, 1, OR_logicFunction(test2)))
print("OR({}, {}) = {}".format(1, 0, OR_logicFunction(test3)))
print("OR({}, {}) = {}".format(1, 1, OR_logicFunction(test4)))`,

    exp09: `mport numpy as np
import matplotlib.pyplot as plt

def estimate_coef(x, y):
    # number of observations/points
    n = np.size(x)

    # mean of x and y vector
    m_x, m_y = np.mean(x), np.mean(y)

    # calculating cross-deviation and deviation about x
    SS_xy = np.sum(y * x) - n * m_y * m_x
    SS_xx = np.sum(x * x) - n * m_x * m_x

    # calculating regression coefficients
    b_1 = SS_xy / SS_xx
    b_0 = m_y - b_1 * m_x

    return b_0, b_1

def plot_regression_line(x, y, b):
    # plotting the actual points as scatter plot
    plt.scatter(x, y, color="m", marker="o", s=30)

    # predicted response vector
    y_pred = b[0] + b[1] * x

    # plotting the regression line
    plt.plot(x, y_pred, color="g")

    # putting labels
    plt.xlabel('x')
    plt.ylabel('y')

    # function to show plot
    plt.show()

def main():
    # observations
    x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
    y = np.array([1, 3, 2, 5, 7, 8, 8, 9, 10, 12])

    # estimating coefficients
    b = estimate_coef(x, y)
    print("Estimated coefficients:\nb_0 = {:.2f} \nb_1 = {:.2f}".format(b[0], b[1]))

    # plotting regression line
    plot_regression_line(x, y, b)

if _name_ == "_main_":
    main()`
  };

  function copyCode(exp) {
    navigator.clipboard.writeText(codes[exp]).then(() => {
      document.getElementById('notice').textContent = `Code for ${exp.toUpperCase()} copied to clipboard!`;
    });
  }
</script>

</body>
</html>
